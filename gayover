#include <algorithm>
#include <iomanip>
#include <iostream>
#include <string>
#include <vector>
#include <cmath>

// const int BASE = 10;

namespace lab_bigint {

class bigint {
public:
    bigint() : number({0}) {}

    // cppcheck-suppress noExplicitConstructor
    bigint(const std::string &digit) : number(){
        size_t start = 0;
        while (start < digit.length() && digit[start] == '0') {
            ++start;
        }
        if (start == digit.length()) {
            number.push_back(0);
        } else {
        size_t pos = digit.length();
            while (pos > start) {
                size_t chunk_start =
                (pos >= base_length) ? pos - base_length : start;
                std::string chunk = digit.substr(chunk_start, pos - chunk_start);
                int chunk_value = std::stoi(chunk);
                number.push_back(chunk_value);
                pos = chunk_start;
            }
        }
    }
    // cppcheck-suppress noExplicitConstructor
    bigint(unsigned int digit) : number() {
        if (digit == 0) {
            number.push_back(0);
        } else {
            while (digit > 0) {
                number.push_back(digit % BASE);
                digit /= BASE;
            }
        }
    }

    friend std::ostream &operator<<(std::ostream &os, const bigint &num);

    friend bool operator==(const bigint &, const bigint &);
    friend bool operator!=(const bigint &, const bigint &);
    friend bool operator>(const bigint &, const bigint &);
    friend bool operator>=(const bigint &, const bigint &);
    friend bool operator<(const bigint &, const bigint &);
    friend bool operator<=(const bigint &, const bigint &);
    [[nodiscard]] std::string to_string() const;
    friend size_t size(const bigint &);

    explicit operator unsigned int() const {
        int result = 0;
        int power = 1;
        for (const auto &digit : number) {
            result += digit * power;
            power *= BASE;
        }
        return result;
    }

    friend bigint operator+(const bigint &lhs, const bigint &rhs) {
        bigint result = lhs;
        result += rhs;
        return result;
    }

    bigint& operator+=(const bigint &other) {
        int carry = 0;
        for (size_t i = 0; i < std::max(size(*this), size(other)); ++i) {
            if (i >= this->number.size()) {
                this->number.push_back(0);
            }
            this->number[i] += carry + (i < size(other) ? other.number[i] : 0);
            carry = this->number[i] / BASE;
            this->number[i] %= BASE;
        }
        if (carry != 0) {
            this->number.push_back(carry);
        }
        return *this;
    }

    friend bigint operator-(const bigint lhs, const bigint &rhs) {
        bigint result = lhs;
        result -= rhs;
        return result;
    }
    
    bigint& operator-=(const bigint &other) {
        int carry = 0;
        for (size_t i = 0; i < size(*this); ++i) {
            this->number[i] += carry;
            if (i < size(other)) {
                this->number[i] -= other.number[i];
            }
            if (this->number[i] < 0) {
                this->number[i] += BASE;
                carry = -1;
            } else {
                carry = 0;
            }
        }
        while (this->number.back() == 0 && this->number.size() > 1) {
            this->number.pop_back();
        }
        return *this;
    }
    bigint operator++(int);
    bigint operator--(int);
    bigint &operator++();
    bigint &operator--();

private:
    static const int base_length;
    std::vector<int> number;
};

const int bigint::base_length = []() {
    return log10(BASE);
}();



size_t size(const bigint &a) {
    return a.number.size();
}


bool operator==(const bigint &lhs, const bigint &rhs) {
    return lhs.number == rhs.number;
}
    
bool operator!=(const bigint &lhs, const bigint &rhs) {
    return !(lhs == rhs);
}
bool operator<(const bigint &lhs, const bigint &rhs) {
    unsigned int n = size(lhs);
    unsigned int m = size(rhs);
    if (n != m) {
        return n < m;
    }
    while (n > 0) {
        --n;
        if (lhs.number[n] != rhs.number[n]) {
            return lhs.number[n] < rhs.number[n];
        }
    }
    return false;
}

bool operator>(const bigint &lhs, const bigint &rhs) {
    return rhs < lhs;
}

bool operator>=(const bigint &lhs, const bigint &rhs) {
    return !(lhs < rhs);
}

bool operator<=(const bigint &lhs, const bigint &rhs) {
    return !(lhs > rhs);
}

std::string bigint::to_string() const {
    std::string result;
    if (number.empty()) {
        return "0";
    }
    result = std::to_string(number.back());
    for (size_t i = number.size() - 1; i-- > 0;) {
        if (std::to_string(number[i]).length() < base_length) {
            result += std::string(base_length - std::to_string(number[i]).length(), '0');
        }
        result += std::to_string(number[i]);
    }
    return result;
}


bigint bigint::operator++(int) {
    bigint result = *this;
    ++(*this);
    return result;
}

bigint bigint::operator--(int) {
    bigint result = *this;
    --(*this);
    return result;
}

bigint &bigint::operator++() {
    *this += 1;
    return *this;
}

bigint &bigint::operator--() {
    *this -= 1;
    return *this;
}

std::ostream &operator<<(std::ostream &os, const bigint &num) {
    if (num.number.empty()) {
        os << '0';
        return os;
    }
    auto rit = num.number.rbegin();
    os << *rit;
    ++rit;
    for (; rit != num.number.rend(); ++rit) {
        os << std::setw(bigint::base_length) << std::setfill('0') << *rit;
    }
    return os;
}

std::istream &operator>>(std::istream &is, bigint &num) {
    std::string str;
    is >> str;
    num = bigint(str);
    return is;
}

}  // namespace lab_bigint
