#include <algorithm>
#include <iomanip>
#include <iostream>
#include <string>
#include <vector>
#include <cmath>

// const int BASE = 10;

namespace lab_bigint {

class bigint {
public:
    bigint() : number({0}) {
    }

    // cppcheck-suppress noExplicitConstructor
    bigint(const std::string &);
    // cppcheck-suppress noExplicitConstructor
    bigint(unsigned int digit);

    friend std::ostream &operator<<(std::ostream &os, const bigint &num);

    friend bool operator==(const bigint &, const bigint &);
    friend bool operator!=(const bigint &, const bigint &);
    friend bool operator>(const bigint &, const bigint &);
    friend bool operator>=(const bigint &, const bigint &);
    friend bool operator<(const bigint &, const bigint &);
    friend bool operator<=(const bigint &, const bigint &);
    [[nodiscard]] std::string to_string() const;
    friend size_t size(const bigint &);

    explicit operator unsigned int() const {
        int result = 0;
        int power = 1;
        for (const auto &digit : number) {
            result += digit * power;
            power *= BASE;
        }
        return result;
    }

    friend bigint operator+(const bigint &, const bigint &);
    friend bigint operator+=(bigint &, const bigint &);
    friend bigint operator-(const bigint &, const bigint &);
    friend bigint operator-=(bigint &, const bigint &);
    bigint operator++(int);
    bigint operator--(int);
    bigint &operator++();
    bigint &operator--();

private:
    static const int base_length;
    std::vector<int> number;
};

const int bigint::base_length = []() {
    return log10(BASE);
}();

bigint::bigint(const std::string &digit) {
    size_t start = 0;
    while (start < digit.length() && digit[start] == '0') {
        ++start;
    }
    if (start == digit.length()) {
        number.push_back(0);
    } else {
        size_t pos = digit.length();
        while (pos > start) {
            size_t chunk_start =
                (pos >= base_length) ? pos - base_length : start;
            std::string chunk = digit.substr(chunk_start, pos - chunk_start);
            int chunk_value = std::stoi(chunk);
            number.push_back(chunk_value);
            pos = chunk_start;
        }
    }
}

bigint::bigint(unsigned int digit) {
    if (digit == 0) {
        number.push_back(0);
    } else {
        while (digit > 0) {
            number.push_back(digit % BASE);
            digit /= BASE;
        }
    }
}

size_t size(const bigint &a) {
    return a.number.size();
}

bool operator==(const bigint &lhs, const bigint &rhs) {
    return lhs.number == rhs.number;
}

bool operator!=(const bigint &lhs, const bigint &rhs) {
    return !(lhs == rhs);
}

bool operator<(const bigint &lhs, const bigint &rhs) {
    unsigned int n = size(lhs);
    unsigned int m = size(rhs);
    if (n != m) {
        return n < m;
    }
    while (n > 0) {
        --n;
        if (lhs.number[n] != rhs.number[n]) {
            return lhs.number[n] < rhs.number[n];
        }
    }
    return false;
}

bool operator>(const bigint &lhs, const bigint &rhs) {
    return rhs < lhs;
}

bool operator>=(const bigint &lhs, const bigint &rhs) {
    return !(lhs < rhs);
}

bool operator<=(const bigint &lhs, const bigint &rhs) {
    return !(lhs > rhs);
}

std::string bigint::to_string() const {
    std::string result;
    if (number.empty()) {
        return "0";
    }
    result = std::to_string(number.back());
    for (size_t i = number.size() - 1; i-- > 0;) {
        if (std::to_string(number[i]).length() < base_length) {
            result += std::string(base_length - std::to_string(number[i]).length(), '0');
        }
        result += std::to_string(number[i]);
    }
    return result;
}


[[nodiscard]] bigint operator+(const bigint &lhs, const bigint &rhs) {
    bigint result;
    int carry = 0;
    result.number.clear();
    for (size_t i = 0; i < std::max(size(lhs), size(rhs)); ++i) {
        int sum = carry;

        if (i < size(lhs)) {
            sum += lhs.number[i];
        }
        if (i < size(rhs)) {
            sum += rhs.number[i];
        }
        result.number.push_back(sum % BASE);
        carry = sum / BASE;
    }
    if (carry != 0) {
        result.number.push_back(carry);
    }
    return result;
}

bigint operator+=(bigint &lhs, const bigint &rhs) {
    lhs = lhs + rhs;
    return lhs;
}

[[nodiscard]] bigint operator-(const bigint &lhs, const bigint &rhs) {
    bigint result;
    result.number.clear();
    int carry = 0;
    for (size_t i = 0; i < size(lhs); ++i) {
        int sum = carry;
        sum += lhs.number[i];
        if (i < size(rhs)) {
            sum -= rhs.number[i];
        }
        if (sum < 0) {
            sum += BASE;
            carry = -1;
        } else {
            carry = 0;
        }
        result.number.push_back(sum);
    }
    while (result.number.back() == 0 && result.number.size() > 1) {
        result.number.pop_back();
    }
    return result;
}

bigint operator-=(bigint &lhs, const bigint &rhs) {
    lhs = lhs - rhs;
    return lhs;
}

bigint bigint::operator++(int) {
    bigint result = *this;
    ++(*this);
    return result;
}

bigint bigint::operator--(int) {
    bigint result = *this;
    --(*this);
    return result;
}

bigint &bigint::operator++() {
    *this += 1;
    return *this;
}

bigint &bigint::operator--() {
    *this -= 1;
    return *this;
}

std::ostream &operator<<(std::ostream &os, const bigint &num) {
    if (num.number.empty()) {
        os << '0';
        return os;
    }
    auto rit = num.number.rbegin();
    os << *rit;
    ++rit;
    for (; rit != num.number.rend(); ++rit) {
        os << std::setw(bigint::base_length) << std::setfill('0') << *rit;
    }
    return os;
}

std::istream &operator>>(std::istream &is, bigint &num) {
    std::string str;
    is >> str;
    num = bigint(str);
    return is;
}

}  // namespace lab_bigint
